// Generated by CoffeeScript 1.6.3
var Client, Crypto, HTTPS, Iconv, QueryString, RSA;

HTTPS = require('https');

Crypto = require('crypto');

RSA = require('ursa');

Iconv = require('iconv-lite');

QueryString = require('qs');

Client = (function() {
  Client.SERVER_NAME = 'w.qiwi.com';

  Client.SERVER_PORT = 443;

  Client.REQUEST_CHARSET = 'utf-8';

  Client.CIPHER_IV = new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);

  function Client() {
    this._host = this.constructor.SERVER_NAME;
    this._port = this.constructor.SERVER_PORT;
    this._sessionId = null;
    this._key = null;
    this._charset = 'utf-8';
  }

  Client.prototype._encrypt = function(data) {
    var cipher, encryptedText;
    cipher = Crypto.createCipheriv('aes-256-cbc', this._key, this.constructor.IV);
    encryptedText = cipher.update(data).toString('hex');
    encryptedText += cipher.final().toString('hex');
    return 'v3.qiwi-' + this._sessionId + '\n' + new Buffer(encryptedText, 'hex').toString('base64');
  };

  Client.prototype._decrypt = function(data) {
    var decipher, decryptedText;
    decipher = Crypto.createDecipheriv('aes-256-cbc', this._key, this.constructor.IV);
    decryptedText = decipher.update(data, 'base64').toString('utf8');
    return decryptedText += decipher.final().toString('utf8');
  };

  Client.prototype._requestOptions = function(endpoint, body) {
    var headers, options, path;
    path = '/xml/xmlutf_' + endpoint + '.jsp';
    headers = {
      'Content-Type': 'application/x-www-form-urlencoded; charset=' + this._charset,
      'Content-Length': body.length
    };
    options = {
      host: this._host,
      port: this._port,
      method: 'POST',
      path: path,
      headers: headers
    };
    return options;
  };

  Client.prototype._responseHandler = function(callback) {
    return function(response) {
      var chunks;
      chunks = [];
      response.on('readable', function() {
        chunks.push(response.read());
        return void 0;
      });
      response.on('end', function() {
        var body;
        body = Buffer.concat(chunks);
        callback(null, body.toString('utf-8'));
        return void 0;
      });
      return void 0;
    };
  };

  Client.prototype.setExtra = function(name, value) {
    this._extra[name] = value;
    return this;
  };

  Client.prototype.removeExtra = function(name) {
    delete this._extra[name];
    return this;
  };

  Client.prototype.sendRequest = function(endpoint, data, callback) {
    var body, request;
    body = Iconv.encode(QueryString.stringify(data), this._charset);
    request = HTTPS.request(this._requestOptions(endpoint, body));
    request.on('response', this._responseHandler(callback));
    request.on('error', function(error) {
      if (typeof callback === "function") {
        callback(error);
      }
      return void 0;
    });
    request.end(body);
    return this;
  };

  Client.prototype.sendEncryptedRequest = function(endpoint, data, callback) {
    var body, encryptedText, request;
    encryptedText = this._encrypt(data);
    body = Iconv.encode(encryptedText, this._charset);
    request = HTTPS.request(this._requestOptions(endpoint, body));
    request.on('response', this._responseHandler(callback));
    request.on('error', function(error) {
      if (typeof callback === "function") {
        callback(error);
      }
      return void 0;
    });
    request.end(body);
    return this;
  };

  Client.prototype.createSession = function(publicKey, callback) {
    var _this = this;
    this.sendRequest('newcrypt_init_session', {
      command: 'init_start'
    }, function(error, data) {
      var aesKey, blob, encodedKey, initSalt, input, sessionId;
      initSalt = new Buffer(data.match(/<init_hs>(.*)<\/init_hs>/)[1], 'base64');
      sessionId = data.match(/<session_id>(.*)<\/session_id>/)[1];
      aesKey = Crypto.randomBytes(32);
      blob = new Buffer(2 + initSalt.length + aesKey.length);
      blob[0] = initSalt.length;
      initSalt.copy(blob, 1);
      blob[1 + initSalt.length] = aesKey.length;
      aesKey.copy(blob, 1 + initSalt.length + 1);
      encodedKey = publicKey.encrypt(blob, null, 'base64', RSA.RSA_PKCS1_PADDING);
      input = {
        command: 'init_get_key',
        session_id: sessionId,
        key_hs: encodedKey,
        key_v: 2
      };
      _this.sendRequest('newcrypt_init_session', input, function(error, data) {
        var session;
        if (error == null) {
          session = Object.create(null);
          session.id = sessionId;
          session.key = aesKey;
          if (typeof callback === "function") {
            callback(null, session);
          }
        } else {
          if (typeof callback === "function") {
            callback(error);
          }
        }
        return void 0;
      });
      return void 0;
    });
    return this;
  };

  Client.prototype.openSession = function(publicKey, callback) {
    var _this = this;
    return this.createSession(publicKey, function(error, session) {
      if (error == null) {
        _this.session = session;
      }
      if (typeof callback === "function") {
        callback(error);
      }
      return void 0;
    });
  };

  return Client;

})();

module.exports = Client;
